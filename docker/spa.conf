# SPA-specific configuration for Vue Router
# This file contains location blocks specifically for Single Page Application routing

# Handle common SPA routes that should serve index.html
location ~ ^/(dashboard|profile|settings|documents|admin|users|reports|analytics) {
    try_files $uri $uri/ @spa_fallback;
    
    # Prevent caching of HTML content
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
    
    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
}

# Handle nested routes (for Vue Router with nested routing)
location ~ ^/(dashboard|profile|settings|documents|admin|users|reports|analytics)/.* {
    try_files $uri $uri/ @spa_fallback;
    
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
}

# SPA fallback location
location @spa_fallback {
    rewrite ^.*$ /index.html last;
    
    # Ensure no caching for the fallback
    add_header Cache-Control "no-cache, no-store, must-revalidate" always;
    add_header Pragma "no-cache" always;
    add_header Expires "0" always;
    
    # Security headers for SPA content
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # CSP for SPA (adjust based on your app's needs)
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src 'self' data: https:; connect-src 'self' https: ws: wss:;" always;
}

# Handle Vue Router history mode 404s
location ~ ^/[^/]*$ {
    # Check if it's a real file first
    try_files $uri $uri.html $uri/index.html @check_spa_route;
}

# Secondary check for SPA routes
location @check_spa_route {
    # If the URI doesn't contain a file extension, treat as SPA route
    if ($uri !~ \.[^/]*$) {
        rewrite ^.*$ /index.html last;
    }
    
    # Otherwise, return 404
    return 404;
}

# Handle deep-linked routes with parameters
location ~ ^/[^/]+/[^/]+ {
    # Try the exact path first, then fall back to SPA
    try_files $uri @spa_parameter_fallback;
}

location @spa_parameter_fallback {
    # Check if this looks like a SPA route (no file extension)
    if ($uri !~ \.[^/]*$) {
        rewrite ^.*$ /index.html last;
    }
    
    # Return 404 for files that don't exist
    return 404;
}

# Special handling for PWA routes
location ~ ^/(offline|manifest)$ {
    try_files $uri @spa_fallback;
    
    # Cache PWA routes briefly
    add_header Cache-Control "no-cache, max-age=300";
}

# Handle service worker requests
location = /sw.js {
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
    
    try_files $uri =404;
}

# WebSocket upgrade support (for HMR in development)
location /ws {
    proxy_pass http://backend_api;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    
    # WebSocket specific timeouts
    proxy_connect_timeout 7d;
    proxy_send_timeout 7d;
    proxy_read_timeout 7d;
}